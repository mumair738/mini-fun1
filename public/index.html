<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Correct Viewport for full responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Base NFT Mint</title>
  <meta name="description" content="Mint free NFTs capturing live ETH price" />
  <meta property="og:title" content="Base NFT Mint" />
  <meta property="og:description" content="Mint free NFTs capturing live ETH price" />

  <!-- **ACTION REQUIRED**: Replace the href with the URL of your actual app logo (e.g., a 64x64 transparent PNG). -->
  <link rel="icon" type="image/png" href="https://assets-global.website-files.com/64b589417d470659a8508e6e/65f97cc1c34a2608c704259b_celo.png">
  <!-- *** END: ADDED METADATA *** -->

  <!-- Google Fonts for NFT typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Monoton&family=Orbitron&family=Roboto+Mono&family=VT323&display=swap" rel="stylesheet">

  <!-- Farcaster Mini App Metadata -->
  <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://mini-fun1.vercel.app/image.png",
    "button":{
      "title":"Base NFT",
      "action":{
        "type":"launch_miniapp",
        "name":"MINT",
        "url":"https://mini-fun1.vercel.app",
        "splashImageUrl":"https://mini-fun1.vercel.app/splash.png",
        "splashBackgroundColor":"#111111"
      }
    }
  }' />

  <style>
    body {
      margin: 0;
      background: #111;
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      /* Keep body padding for spacing around the edges */
      padding: 5px 5px;
      box-sizing: border-box;
      text-align: center;
    }
    .tradingview-widget-container {
      width: 100%;
      max-width: 390px;
      height: 300px;
      border: 1px solid #333;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    #celo-chart {
        height: 100%;
        width: 100%;
    }
    .status-box {
      font-size: 1rem;
      padding: 8px 12px;
      border-radius: 8px;
      text-align: center;
      width: 90%;
      max-width: 320px;
      margin-bottom: 12px;
    }
    .status-info { background: #1e40af; }
    .status-warning { background: #b45309; }
    .status-success { background: #16a34a; }
    .status-error { background: #b91c1c; }
    .action-button {
      padding: 1rem 2rem;
      font-size: 1.2rem;
      font-weight: bold;
      color: #0f0f0f;
      background: linear-gradient(90deg, #49dfb5, #7dd3fc);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-bottom: 12px;
      box-shadow: 0 2px 8px #0008;
      transition: background 0.2s, color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .action-button:disabled {
      background: #888 !important;
      color: #444;
      cursor: not-allowed;
    }
    .preview-button {
        background: linear-gradient(90deg, #f97316, #fcd34d); /* Orange/Yellow gradient */
        font-size: 1rem;
        padding: 0.75rem 1.5rem;
    }
    .addresses-box {
      background: #131417;
      font-size: 0.9rem;
      padding: 6px 10px;
      border-radius: 7px;
      margin-bottom: 12px;
      width: 85%;
      max-width: 330px;
      word-break: break-all;
      color: #c3cfe8;
      text-align: center;
    }
    footer {
      margin-top: auto;
      display: flex;
      gap: 24px;
      padding-bottom: 12px;
    }
    footer svg {
      fill: #fafafa;
      width: 28px;
      height: 28px;
    }
    .hidden { display:none; }

    /* FIX: Implement responsive, non-cropping scaling */
    #nft-preview-container {
        margin-top: 10px;
        margin-bottom: 10px;
        width: 100%;
        max-width: 390px;
        background: #000;
        border: 2px solid #49dfb5;
        border-radius: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        position: relative;
        /* allow vertical growth up to viewport, then scroll */
        max-height: 60vh;
        overflow: hidden;      /* <-- Changed from auto to hidden to remove scroll */
        box-sizing: border-box;
    }

    /* Make inline SVG scale naturally without distortion */
    #nft-preview-container svg {
      display: block;
      width: 100%;    /* scale horizontally up to container width */
      height: auto;   /* preserve aspect ratio */
      max-height: 60vh; /* prevents it pushing page off-screen */
      margin: 0 auto;
      box-sizing: border-box;
    }

    /* Fallback for image-type tokenURI (data:image/...), if present */
    #nft-preview-container img {
      display: block;
      width: 100%;
      height: auto;
      max-height: 60vh;
      margin: 0 auto;
    }
    /* --- START NEW SPARKLE CSS (UNCHANGED) --- */
    .sparkles::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(circle, white 2px, transparent 2px);
      background-size: 20px 20px;
      pointer-events: none;
      opacity: 0.7;
      animation: sparkle 6s linear infinite;
      z-index: 10;
    }

    @keyframes sparkle {
      0% { background-position: 0 0; opacity: 0.6; }
      50% { background-position: 10px 10px; opacity: 1; }
      100% { background-position: 0 0; opacity: 0.6; }
    }

    .common.sparkles::before {
      background: radial-gradient(circle, #bbb 1.5px, transparent 2px);
      animation-duration: 6s;
    }
    .rare.sparkles::before {
      background: radial-gradient(circle, #2196f3 2.5px, transparent 2px);
      animation-duration: 4s;
    }
    .legendary.sparkles::before {
      background: radial-gradient(circle, gold 3.5px, transparent 2px);
      animation-duration: 2s;
    }
    .mythic.sparkles::before {
      background: radial-gradient(circle, crimson 4px, transparent 2px);
      animation-duration: 1.5s;
    }
    /* --- END NEW SPARKLE CSS --- */
    /* Spinner CSS for Loading Indicator (UNCHANGED) */
    .spinner {
      border: 2px solid #fff3;
      border-top: 2px solid #fff;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: inline-block;
      animation: spin 0.6s linear infinite;
    }
    @keyframes spin { 100% { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <!-- 1. Live ETH chart -->
  <div class="tradingview-widget-container" role="img" aria-label="Live CELO Price Chart">
    <div id="celo-chart"></div>
    <script src="https://s3.tradingview.com/tv.js"></script>
    <script>
      new TradingView.widget({
        autosize: true,
        symbol: "BINANCE:ETHUSDT",
        interval: "60",
        theme: "dark",
        style: "1",
        hide_top_toolbar: true,
        withdateranges: false,
        toolbar_bg: "#1f1f1f",
        locale: "en",
        enable_publishing: false,
        allow_symbol_change: false,
        container_id: "celo-chart"
      });
    </script>
  </div>

  <h1>Mint Your ETH Price NFT</h1>

  <!-- User Address -->
  <div id="userAddressBox" class="addresses-box hidden"></div>
  <!-- Total Minted - Initial content will be updated by JS -->
  <div id="totalSupply" class="status-box status-warning">
    <!-- JS will inject spinner here -->
  </div>
  <!-- Mint Button -->
  <button class="action-button" id="mintBtn">MINT</button>
  <!-- Preview Button (hidden until mint success) -->
  <button class="action-button preview-button hidden" id="previewBtn">Preview NFT</button>

  <!-- Status Box with Accessibility Attribute -->
  <div id="statusBox" class="status-box" aria-live="polite"></div>

  <!-- NFT SVG Preview -->
  <div id="nft-preview-container" class="hidden">
      <!-- SVG will be injected here -->
  </div>

  <!-- Footer -->
  <footer>
    <a href="https://farcaster.xyz/dare1.eth" target="_blank" aria-label="Farcaster">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"/><path d="M12 7c-2.757 0-5 2.243-5 5s2.243 5 5 5 5-2.243 5-5-2.243-5-5-5zm0 8c-1.654 0-3-1.346-3-3s1.346-3 3-3 3 1.346 3 3-1.346 3-3 3z"/></svg>
    </a>
    <a href="https://x.com/kumar14700" target="_blank" aria-label="Twitter">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 16 16"><path d="M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Zm-.86 13.028h1.36L4.323 2.145H2.865l8.875 11.633Z"/></svg>
    </a>
  </footer>

  <!-- Farcaster SDK (UNCHANGED) -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    sdk.actions.ready({ disableNativeGestures: true });
  </script>

  <!-- Wagmi + Base Logic -->
  <script type="module">
    import {
      createConfig,
      connect,
      writeContract,
      readContract,
      http,
      waitForTransactionReceipt,
      watchAccount // <-- IMPORTED watchAccount
    } from 'https://esm.sh/@wagmi/core';
    import { base } from 'https://esm.sh/@wagmi/core/chains';
    import { http } from 'https://esm.sh/@wagmi/core';
    import { farcasterMiniApp } from 'https://esm.sh/@farcaster/miniapp-wagmi-connector';
    import { parseEther } from 'https://esm.sh/viem';

    // Configuration: Change this if your contract function name is different
    const MAX_SUPPLY_FUNCTION_NAME = 'maxSupply';

    const statusBox    = document.getElementById('statusBox');
    const supplyBox    = document.getElementById('totalSupply');
    const mintBtn      = document.getElementById('mintBtn');
    const previewBtn   = document.getElementById('previewBtn');
    const userAddrBox  = document.getElementById('userAddressBox');
    const previewContainer = document.getElementById('nft-preview-container');
    // Array of all possible rarity classes for quick removal (4 Tiers: Common, Rare, Legendary, Mythic)
    const ALL_RARITY_CLASSES = ["common", "rare", "legendary", "mythic"];

    let MAX_SUPPLY = 0; // Dynamic supply limit, 0 means unlimited/unknown
    let lastMintedTokenId = null;
    let contractAddress = null;
    let mintPriceWei = 0n; // Use BigInt for wei values
    let userAddress = null; // <-- DECLARED userAddress to track state

    function setStatus(msg, type = 'info') {
      // Clear all previous content, including DOM elements used for links
      statusBox.innerHTML = '';

      // Add emoji indicators based on type
      let icon = '';
      if (type === 'success') icon = '✅ ';
      else if (type === 'error') icon = '❌ ';
      else if (type === 'warning') icon = '⚠️ ';
      else if (type === 'info') icon = 'ℹ️ '; // Use 'info' for neutral messages

      statusBox.className = `status-box status-${type}`;
      statusBox.insertAdjacentText('afterbegin', icon + msg);
    }

    function showAddress(addr) {
      const shortAddr = `${addr.slice(0, 6)}...${addr.slice(-4)}`;
      userAddrBox.textContent = `Your address: ${shortAddr}`;
      userAddrBox.classList.remove('hidden');
    }

    // --- Price fetching function ---
    async function fetchEthPrice() {
      try {
        const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        // Check if data structure is as expected
        if (!data || !data.ethereum || !data.ethereum.usd) {
             throw new Error("Invalid response structure from CoinGecko.");
        }
        const price = data.ethereum.usd;
        return price;
      } catch (e) {
        console.error("Failed to fetch ETH price:", e);
        throw new Error("Failed to fetch ETH price. Please try again.");
      }
    }

    // Setup wagmi config for Base
    const wagmiConfig = createConfig({ // <-- RENAMED to wagmiConfig
      chains: [base],
      transports: { [base.id]: http() }
    });

    let contractDetails;

    // Helper function to adjust injected SVG attributes for responsive scaling
    function adjustInjectedSvg(container) {
      const svg = container.querySelector('svg');
      if (svg) {
        // If no viewBox but width/height exist, create a viewBox from them
        if (!svg.hasAttribute('viewBox')) {
          const w = svg.getAttribute('width');
          const h = svg.getAttribute('height');
          if (w && h) {
            // parseFloat to handle "400px" etc.
            const W = parseFloat(w);
            const H = parseFloat(h);
            if (!isNaN(W) && !isNaN(H) && W > 0 && H > 0) {
              svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
            }
          }
        }

        // Preserve aspect ratio so nothing gets cropped
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

        // Let CSS control the sizing (remove inline width/height)
        svg.removeAttribute('width');
        svg.removeAttribute('height');

        // Ensure CSS max-height will work
        svg.style.width = '100%';
        svg.style.height = 'auto';
        svg.style.maxHeight = '60vh';
        svg.style.display = 'block';
      } else {
        // If metadata.image was a raster (PNG/JPEG) injected as <img>, style it
        const img = container.querySelector('img');
        if (img) {
          img.style.width = '100%';
          img.style.height = 'auto';
          img.style.maxHeight = '60vh';
          img.style.display = 'block';
        }
      }

      // We are removing the scroll, so only set max-height
      container.style.maxHeight = '60vh';
    }


    (async () => {
      // 1. Persist Last Mint: Load from localStorage on startup
      lastMintedTokenId = localStorage.getItem("lastMintedTokenId");
      if (lastMintedTokenId) {
          previewBtn.innerText = `Preview NFT #${lastMintedTokenId}`;
          previewBtn.classList.remove('hidden');
      }
  
      // Alias for consistency in mint function
      const fetchCeloPrice = fetchEthPrice;

      let chainId;

      // Connect wallet
      try {
        const conn = await connect(wagmiConfig, { connector: farcasterMiniApp() });
        userAddress = conn.accounts[0]; // <-- SET userAddress
        chainId = conn.chainId;
        showAddress(userAddress);

        // Optional: prompt to add app (requires valid farcaster.json).
        const hasPromptedAddApp = sessionStorage.getItem('hasPromptedAddApp');
        if (!hasPromptedAddApp && sdk?.actions?.addMiniApp) {
          try {
            await sdk.actions.addMiniApp();
          } catch(_) {}
          sessionStorage.setItem('hasPromptedAddApp', 'true');
        }
      } catch (err) {
        console.error("Initialization failed:", err);
        setStatus('Failed to initialize. Please reopen in Warpcast.', 'error');
      }

      // 2. Network Guard
      if (chainId !== base.id) {
          setStatus("Please switch to Base Mainnet.", 'warning');
          mintBtn.disabled = true;
          mintBtn.title = "Switch to Base Mainnet to mint.";
          return;
      } else {
          mintBtn.title = "";
      }

      // 3. Load contract JSON
      try {
        contractDetails = await fetch('./contract.json').then(r => r.json());
        contractAddress = contractDetails.address;
      } catch (e) {
        setStatus("Missing contract details. Ensure 'contract.json' is deployed.", 'error');
        console.error(e);
        mintBtn.disabled = true;
        return;
      }

      if(!contractDetails || !userAddress) {
          mintBtn.disabled = true;
          return;
      }

      // 4. Fetch MAX_SUPPLY & MINT_PRICE dynamically
      try {
          const [max, price] = await Promise.all([
              readContract(wagmiConfig, {
                  address: contractDetails.address,
                  abi: contractDetails.abi,
                  functionName: MAX_SUPPLY_FUNCTION_NAME
              }),
              readContract(wagmiConfig, {
                  address: contractDetails.address,
                  abi: contractDetails.abi,
                  functionName: 'mintPrice'
              })
          ]);
          MAX_SUPPLY = Number(max);
          mintPriceWei = BigInt(price);

          // Update button label with price
          if (mintPriceWei > 0n) {
             const celoPrice = Number(mintPriceWei) / 1e18;
             mintBtn.innerText = `MINT (${celoPrice.toFixed(4)} CELO)`;
          }

      } catch (e) {
          setStatus(`Could not read contract settings. Assuming unlimited/free.`, 'warning');
          MAX_SUPPLY = 0; // 0 means unlimited/unknown for this logic
          mintPriceWei = 0n;
          console.warn(`Failed to read contract settings.`, e);
      }

      // 5. Fetch totalSupply
      await updateSupply(true);
    })();


    // Function to update the total supply display and check for sold out status
    async function updateSupply(initialLoad = false) {
        if (initialLoad) {
            supplyBox.innerHTML = '<span class="spinner"></span> Loading supply...';
        }

        try {
            // Add a small delay if not initial load to allow blockchain state to update
            if (!initialLoad) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            const total = await readContract(wagmiConfig, {
                address: contractDetails.address,
                abi: contractDetails.abi,
                functionName: 'totalSupply'
            });

            const totalNumber = Number(total);

            // Check if MAXSUPPLY is defined (non-zero)
            if (MAX_SUPPLY > 0) {
                supplyBox.textContent = `Minted: ${totalNumber}/${MAX_SUPPLY}`;

                // Disable mint button if sold out
                if (totalNumber >= MAX_SUPPLY) {
                    mintBtn.disabled = true;
                    mintBtn.innerText = "SOLD OUT";
                    mintBtn.title = "The maximum supply has been reached.";
                    supplyBox.className = "status-box status-error";

                    if (!initialLoad) {
                        setStatus(`All ${MAX_SUPPLY} NFTs have been minted!`, "warning");
                    }
                } else if (!initialLoad) {
                    // Restore active state if it was previously sold out but updated
                    mintBtn.disabled = false;
                    const ethPrice = Number(mintPriceWei) / 1e18;
                    mintBtn.innerText = mintPriceWei > 0n ? `MINT (${ethPrice.toFixed(4)} ETH)` : 'MINT';
                    mintBtn.title = '';
                    supplyBox.className = "status-box status-warning";
                }
            } else {
                // Display total minted only if max supply is not set/unknown
                supplyBox.textContent = `Total Minted: ${totalNumber}`;
                supplyBox.className = "status-box status-info";

                if (!initialLoad) {
                    mintBtn.disabled = false;
                    const ethPrice = Number(mintPriceWei) / 1e18;
                    mintBtn.innerText = mintPriceWei > 0n ? `MINT (${ethPrice.toFixed(4)} ETH)` : 'MINT';
                }
            }

            return total;
        } catch (e) {
            supplyBox.textContent = "Total Minted: N/A";
            console.error(e);
            return 0;
        }
    }


    // Function to fetch and display the NFT SVG
    async function previewNft(tokenId) {
        if (!contractDetails) return;

        // Clear status from any previous attempts
        statusBox.innerHTML = '';
        statusBox.className = 'status-box';

        previewBtn.disabled = true;
        previewBtn.innerHTML = '<span class="spinner"></span> Loading Preview…';
        previewContainer.classList.add('hidden');
        previewContainer.innerHTML = ''; // Clear previous SVG

        // Remove old sparkle and rarity classes before starting
        previewContainer.classList.remove("sparkles", ...ALL_RARITY_CLASSES);

        try {
            // 1. Read the tokenURI from the contract
            const tokenURI = await readContract(wagmiConfig, {
                address: contractAddress,
                abi: contractDetails.abi,
                functionName: 'tokenURI',
                args: [BigInt(tokenId)]
            });

            // 2. Decode the base64 JSON part
            const base64Json = tokenURI.split(',')[1];
            if (!base64Json) throw new Error("Invalid tokenURI format.");

            // FIX: Use decodeURIComponent before atob for robust Base64 decoding,
            const jsonString = atob(decodeURIComponent(base64Json));
            const metadata = JSON.parse(jsonString);

            // 3. Decode the base64 SVG part
            const base64Svg = metadata.image.split(',')[1];
            if (!base64Svg) throw new Error("Invalid image data format.");

            // FIX: Apply the same robust decoding logic to the image (SVG) content.
            let svgString = atob(decodeURIComponent(base64Svg));

            // Security: Sanitize injected SVG
            const safeSvg = svgString.replace(/<script.*?>.*?<\/script>/g, '');

            // 4. Inject the safe SVG into the container
            previewContainer.innerHTML = safeSvg;
            previewContainer.classList.remove('hidden');

            // NEW: adjust the injected SVG so it scales correctly
            adjustInjectedSvg(previewContainer);

            // 5. Apply Sparkle based on Rarity
            let rarityText = "Common"; // Default
            let priceText = "N/A";

            if (metadata.attributes) {
                const rarityAttr = metadata.attributes.find(attr => attr.trait_type === 'Rarity');
                const priceAttr = metadata.attributes.find(attr => attr.trait_type === 'CELO Price Snapshot');

                if (rarityAttr) {
                    rarityText = rarityAttr.value;
                }
                if (priceAttr) priceText = priceAttr.value + " ETH";
            }

            // --- Apply NEW Sparkle Logic ---
            // 1. Ensure base sparkle class is always present
            previewContainer.classList.add("sparkles");

            // 2. Add the specific new rarity class (lowercase)
            const rarityClassLower = rarityText.toLowerCase();
            previewContainer.classList.add(rarityClassLower);
            // --- End NEW Sparkle Logic ---

            const buttonLabel = `Preview NFT #${tokenId} (${rarityText} / $${priceText})`;
            previewBtn.innerText = buttonLabel;

        } catch (e) {
            // Error handling shows the exact error from the screenshot
            setStatus("Failed to load NFT preview. Check console for details.", 'error');
            previewBtn.innerText = 'Preview NFT Error';
            console.error(`NFT Preview Error for token ID ${tokenId}:`, e); // Enhanced console logging
            // Clear preview on error
            previewContainer.classList.add('hidden');
        } finally {
            previewBtn.disabled = false;
        }
    }

    // --- START: ADDED CODE ---
    // --- Event Listener for Wallet Changes ---
    watchAccount(wagmiConfig, {
        onChange(account) {
            // Handle user switching accounts or disconnecting
            if (account.address && account.isConnected) {
                // User switched to a new account, treat as a new connection
                console.log('Account changed to:', account.address);
                userAddress = account.address;
                showAddress(userAddress);
                setStatus('Account changed.', 'info');
                mintBtn.disabled = false;

                // Re-fetch all data for the new user context
                updateSupply(true);
                // Reset mint-specific UI
                previewBtn.classList.add('hidden');
                previewContainer.classList.add('hidden');
                localStorage.removeItem('lastMintedTokenId');
                lastMintedTokenId = null;

            } else if (!account.isConnected && userAddress) {
                // User disconnected the wallet
                console.log('Wallet disconnected');
                userAddress = null;
                userAddrBox.classList.add('hidden');
                setStatus('Wallet disconnected. Please refresh the app.', 'warning');
                mintBtn.disabled = true;

                // Hide and reset everything
                previewBtn.classList.add('hidden');
                previewContainer.classList.add('hidden');
                supplyBox.textContent = 'Connect wallet to see supply';
                localStorage.removeItem('lastMintedTokenId');
                lastMintedTokenId = null;
            }
        },
    });
    // --- END: ADDED CODE ---

    // Minting Handler
    mintBtn.addEventListener('click', async () => {
        if (!contractDetails) {
            setStatus("Contract details are missing. Cannot mint.", "error");
            return;
        }

        // Pre-check for sold out
        if (mintBtn.disabled && mintBtn.innerText === "SOLD OUT") {
            setStatus("This NFT drop is sold out.", "warning");
            return;
        }

        // Clear status from any previous attempts
        statusBox.innerHTML = '';
        statusBox.className = 'status-box';

        // Hide preview button and container before minting
        previewBtn.classList.add('hidden');
        previewContainer.classList.add('hidden');
        // Remove all sparkle/rarity classes
        previewContainer.classList.remove('sparkles', ...ALL_RARITY_CLASSES);

        // Loading Indicator
        mintBtn.disabled = true;
        mintBtn.innerHTML = '<span class="spinner"></span> Minting...';
        lastMintedTokenId = null;

        try {
            const { address, abi } = contractDetails;

            // 1. Get current total supply BEFORE minting
            const currentSupply = await readContract(wagmiConfig, {
                address,
                abi,
                functionName: 'totalSupply'
            });

            // 2. Calculate what the next token ID will be
            const nextTokenId = Number(currentSupply) + 1; // Assumes token IDs start from 1

            // 3. Fetch ETH price
            const price = await fetchEthPrice();
            const priceForContract = Math.floor(price * 10000);

            // 4. Submit mint transaction
            const hash = await writeContract(wagmiConfig, {
                address,
                abi,
                functionName: 'mint',
                args: [priceForContract],
                value: mintPriceWei
            });

            // 5. Wait for the transaction to be confirmed
            setStatus("Confirming transaction...", "info");
            const receipt = await waitForTransactionReceipt(wagmiConfig, { hash });

            if (receipt.status === 'reverted') {
                throw new Error('Transaction was reverted.');
            }

            // 6. Store ID and update UI now that it's confirmed
            localStorage.setItem('lastMintedTokenId', nextTokenId.toString());
            setStatus("Mint Successful! ", "success");

            if (contractAddress) {
                const basescanTokenUrl = `https://basescan.org/token/${contractAddress}?a=${nextTokenId}`;
                const basescanTxUrl = `https://basescan.org/tx/${hash}`;

                const txLink = document.createElement('a');
                txLink.href = celoscanTxUrl;
                txLink.target = '_blank';
                txLink.textContent = 'View Tx';
                txLink.style.cssText = 'color:#fff;text-decoration:underline;margin-left:8px;';

                const tokenLink = document.createElement('a');
                tokenLink.href = basescanTokenUrl;
                tokenLink.target = '_blank';
                tokenLink.textContent = 'View on Basescan';
                tokenLink.style.cssText = 'color:#fff;text-decoration:underline;margin-left:8px;';

                statusBox.appendChild(txLink);
                statusBox.insertAdjacentText('beforeend', ' | ');
                statusBox.appendChild(tokenLink);
            }

            lastMintedTokenId = nextTokenId;

            // 7. Update supply and auto-load preview
            await updateSupply();
            previewBtn.classList.remove('hidden');
            previewBtn.innerText = `Preview NFT #${nextTokenId}`;
            await previewNft(lastMintedTokenId);

        } catch (e) {
            let errorMsg = e.shortMessage || "Mint failed.";

            // NEW: Add specific advice for connection/RPC errors
            if (e.message && (e.message.includes("Invalid parameters were provided to the RPC method") || e.message.includes("RPC"))) {
                errorMsg = "❌ Mint failed due to a connection error. Please reload/refresh the miniapp and try again.";
            } else if (!e.shortMessage) {
                // Generic error catch: recommend refresh as it fixes many mini-app issues
                errorMsg = "❌ Mint failed. This may be caused by a stale connection. Please reload/refresh the miniapp and try again.";
            }

            setStatus(errorMsg, "error");
            console.error('Mint Error:', e);

            // Reset preview state on failure
            previewBtn.classList.add('hidden');
            previewContainer.classList.add('hidden');
            previewContainer.classList.remove('sparkles', ...ALL_RARITY_CLASSES);
            localStorage.removeItem('lastMintedTokenId');
            lastMintedTokenId = null;
        } finally {
            // Only restore MINT text if it's not sold out
            if (mintBtn.innerText !== "SOLD OUT") {
                mintBtn.disabled = false;
                const ethPrice = Number(mintPriceWei) / 1e18;
                mintBtn.innerText = mintPriceWei > 0n ? `MINT (${ethPrice.toFixed(4)} ETH)` : 'MINT';
            }
        }
    });

    // Preview Handler
    previewBtn.addEventListener('click', async () => {
        if (lastMintedTokenId !== null) {
            await previewNft(lastMintedTokenId);
        } else {
            setStatus("No token ID to preview. Please mint first.", 'warning');
        }
    });

  </script>
</body>
</html>